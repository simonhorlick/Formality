// Report aggregates typechecking errors.
type LanguageServer.Report {
  new(
    types: List(Pair(Fm.Name, Fm.Term)),
    errors: List(Fm.Error),
  )
}

LanguageServer.report.go(
    defs: Fm.Defs,
    names: List(Fm.Name),
    errs: List(Fm.Error),
    typs: List(Pair(Fm.Name, Fm.Term))): LanguageServer.Report
  case names {
    // Base-case. We've handled all the definitions so return all of the errors.
    nil: LanguageServer.Report.new(typs, errs),

    cons:
      let name = names.head;

      // Get the top-level definition `name` from `defs`.
      case Fm.get<_>(name, defs) as got {
        // TODO(simon): Should we handle this case?
        none: LanguageServer.report.go(defs, names.tail, errs, typs),
        some: case got.value {
          new:
            let typs = List.append<_>(typs, {name, got.value.type});

            // Inspect the typechecking status of this term, if typechecking
            // failed then report it.
            case got.value.stat {
              init: LanguageServer.report.go(defs, names.tail, errs, typs),
              wait: LanguageServer.report.go(defs, names.tail, errs, typs),
              done: LanguageServer.report.go(defs, names.tail, errs, typs),

              // Retrieve the list of typechecking errors attached to this term.
              fail: case got.value.stat.errors {
                nil: LanguageServer.report.go(defs, names.tail, errs, typs),
                cons:
                  let name_str = Fm.Name.show(got.value.name);
                  let rel_errs = Fm.Error.relevant(got.value.stat.errors,
                    Bool.false);
                  case rel_errs {
                    nil:
                      LanguageServer.report.go(defs, names.tail, errs, typs),
                    cons:
                      let added_errs = List.concat<_>(errs, rel_errs);
                      LanguageServer.report.go(defs, names.tail, added_errs,
                        typs)
                  }
              }
            }
        }
      }
  }

// report collects typechecking errors from the provided definitions.
LanguageServer.report(
    defs: Fm.Defs,
    names: List(Fm.Name)): LanguageServer.Report
  LanguageServer.report.go(defs, names, [], [])

// Diagnostic is a compiler error or warning with an associated source range.
type LanguageServer.Diagnostic {
  new(
    message: String,
    from: Nat,
    upto: Nat,
  )
}

// check runs the typechecker on a single file provided as a string.
LanguageServer.check(
    filename: String,
    code: String): List(LanguageServer.Diagnostic)
  case Fm.Defs.read(filename, code, Map.new<_>) as read {
    left:
      List.pure<_>(LanguageServer.Diagnostic.new(read.value, 0, 0))
    right: IO.purify<List(LanguageServer.Diagnostic)>(do IO {
      let defs = read.value;
      let names = List.mapped<_>(Map.keys<_>(defs))<_>(Fm.Name.from_bits);
      var defs = Fm.Synth.many(names, defs);

      // Collect any errors from typechecking.
      let report = LanguageServer.report(defs, names);
      open report

      // Attach source locations, if available.
      // FIXME: goals do not have source locations.
      let responses = List.mapped<_>(report.errors)<_>((err)
        case Fm.Error.origin(err) as origin {
          none: LanguageServer.Diagnostic.new(Fm.Error.show(err, defs), 0, 0),
          some: case origin.value {
            new:
              LanguageServer.Diagnostic.new(Fm.Error.show(err, defs),
                origin.value.from, origin.value.upto)
          },
        }
      );

      Monad.pure<_>(IO.monad)<_>(responses)
    }),
  }